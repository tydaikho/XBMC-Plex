import re, urlparse, cgi, time, urllib, urllib2, stringfrom datetime import datefrom BeautifulSoup import BeautifulSoup	USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/534.51.22 (KHTML, like Gecko) Version/5.1.1 Safari/534.51.22'def NormalizeURL(url):	#Log("*********** In VidhHog normalizeURL")		# Deal with special providerInfo URL built up by plugin to return	# info about this provider. For all other normal URLs, do nothing. 	if ("providerinfo" in url):			try:			show = Prefs["show_vidhog"]		except Exception, ex:			show = False				if (show):			return url + "&visible=true"		else:			return url				else:		return url	def MetadataObjectForURL(url): 	#Log('In MetadataObjectForURL for VidHog (' + url + ')')		# LMWT Plugin should have access to info about this URL if user used plugin to launch video.	video = LMWTGetVideoClipObjectFromMediaInfo(url)	if video is None:			video = VideoClipObject(			title = 'VidHog Redirect Page',			summary = 'VidHog Redirect Page',			thumb = None,		)		return video	def MediaObjectsForURL(url):	#Log('In MediaObjectsForURL for MovShare (' + url + ')')		return [		MediaObject(			parts = [PartObject(key=Callback(PlayVideo, url=url))],		)	]	@indirect	def PlayVideo(url):	# This used to handle the wait delay on the intial page by breaking 	# down the process into a two step process and returning back to	# the main plugin after the 1st step. Check file history if that	# ever needs to be brought back.		url_parts = urlparse.urlparse(url)	embed_url = urlparse.ParseResult(url_parts.scheme, url_parts.netloc, "/embed-" + url_parts.path[1:] + ".html", "", "", "").geturl()		# Request URL	soup = BeautifulSoup(		HTTP.Request(			embed_url,			cacheTime = 0		).content	)			#Log(soup)	if (soup.find('div',{'id':'player_code'}).a is not None):		final_url = soup.find('div',{'id':'player_code'}).a['href']	else:			# Unpack any JS on page...		soup = BeautifulSoup(packed_process(str(soup.contents[0])))				# Find the right JS element...		player_code = soup.find('div',{'id':'player_code'}).find('script',text=re.compile("^var"))		#Log(player_code)			# There's a couple of different pages lying about....		if ('new SWFObject' in player_code):			final_url = re.search("\\\\'file\\\\',\\\\'([^\\\\]*)",player_code).group(1)		else:			soup = BeautifulSoup(re.search('(<.*>)', player_code).group(1))			final_url = soup.find('param',{'name': 'src'})['value']		Log(final_url)				oc = ObjectContainer(		objects = [			VideoClipObject(				items = [					MediaObject(						parts = [PartObject(key=final_url)]					)				]			)		]	)	# Might as well set a sensible user agent string.	oc.user_agent = USER_AGENT		return oc		def LogProviderError(msg="", ex=None):	Log("************************** PROVIDER ERROR: " + msg)	return []################################################################################ Decode PACKED Methods###############################################################################def unpack(matchObject):	script = matchObject.group(0)		if script is None:		return		#Log(script)		# Look for substitution values.	args_re_res = re.search("return p}\('(.*)',(\d{1,2}),(\d{1,3}),'([^']*)'.split", script)		if (args_re_res is None or args_re_res.group(1) is None):		return None		val_to_unpack = args_re_res.group(1)	key_digits_length = int(args_re_res.group(2))	sub_vals_count = int(args_re_res.group(3))	sub_vals = args_re_res.group(4).split('|')		#Log(val_to_unpack)	#Log(key_digits_length)	#Log(sub_vals_count)	#Log(sub_vals)		# Create dict to map url sub keys to sub values.	sub_vals_dict = dict()		# Create list of valid digits for sub keys.	key_digits = string.digits + string.ascii_lowercase + string.ascii_uppercase[0:key_digits_length]		for index_cnt in range(0, (sub_vals_count / key_digits_length) + 1):			index = index_cnt * key_digits_length		strindex = str(index_cnt) if index_cnt > 0 else ""				for cnt in range(0, key_digits_length):			if (cnt + index < len(sub_vals) and sub_vals[cnt + index]):				sub_vals_dict[strindex + key_digits[cnt]] = sub_vals[cnt + index]			else:				sub_vals_dict[strindex + key_digits[cnt]] = strindex + key_digits[cnt]							#Log(strindex + key_digits[cnt] + '=' + str(cnt + index) + '=' + sub_vals_dict[strindex + key_digits[cnt]])			# Sub values into string to unpack	return (		re.sub(			"[0-9a-zA-Z]{1,2}",			lambda x:  sub_vals_dict[x.group(0)],			val_to_unpack		)	)	def packed_process(contents):	# Look for any script element which contain a packed method.	regEx = re.compile("eval\(function\(p,a,c,k,e,d\).*?\.split\(\'\|\'\).*?\)\)", flags=re.DOTALL)	return regEx.sub(unpack, contents)